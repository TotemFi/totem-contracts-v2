{
  "address": "0xc38B95e659e3F3edb4a97032fB3855711549C6d8",
  "abi": [
    {
      "inputs": [],
      "name": "foo",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x04817b43c3fc0f7bedb1c86644bb8583080ad2b86f7dcefa79b9a66d5065a754",
  "receipt": {
    "to": null,
    "from": "0x6aB29B1766256F01df388B3a25d02C24f454020c",
    "contractAddress": "0xc38B95e659e3F3edb4a97032fB3855711549C6d8",
    "transactionIndex": 1,
    "gasUsed": "746345",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x886e42a1164d36289305734c4c632da56f53c79aed74c612256d86d305dfb55f",
    "transactionHash": "0x04817b43c3fc0f7bedb1c86644bb8583080ad2b86f7dcefa79b9a66d5065a754",
    "logs": [],
    "blockNumber": 13640516,
    "cumulativeGasUsed": "797472",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "9fd82bd0896ab629503482c4e3592c72",
  "metadata": "{\"compiler\":{\"version\":\"0.8.0+commit.c7dfd78e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"foo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/IndexedClaimRewardLib.sol\":\"IndexedClaimRewardLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\",\"keccak256\":\"0xe6f5ac8c47f3b9b6135051efb9216f9ba5b312a6ecc20209b4f66a780443c328\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x35b09b69aca3bc2633da8f47382a81ecf367efe57167a2114f60f9ec81988afa\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x062b5a0f7cc6b0528fa350033759f3a15ba42afb57423d7c593753860f2c82e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8666f020bd8fc9dc14f07e2ebc52b5f236ab4cdde7c77679b08cb2f94730043b\",\"license\":\"MIT\"},\"contracts/Distribution/USDRetriever.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract USDRetriever {\\n    IERC20 internal USDCContract;\\n\\n    event ReceivedTokens(address indexed from, uint256 amount);\\n    event TransferTokens(address indexed to, uint256 amount);\\n    event ApproveTokens(address indexed to, uint256 amount);\\n\\n    function setUSDToken(address _usdContractAddress) internal {\\n        USDCContract = IERC20(_usdContractAddress);\\n    }\\n\\n    function approveTokens(address _to, uint256 _amount) internal {\\n        USDCContract.approve(_to, _amount);\\n        emit ApproveTokens(_to, _amount);\\n    }\\n\\n    function getUSDBalance() external view returns (uint256) {\\n        return USDCContract.balanceOf(address(this));\\n    }\\n\\n    function getUSDToken() external view returns (address) {\\n        return address(USDCContract);\\n    }\\n}\\n\",\"keccak256\":\"0xf8ce825a5e793fc484345dc3f0a6740a30789f5350e78e88ec8299a37b5f6e29\",\"license\":\"UNLICENSED\"},\"contracts/Distribution/WrappedTokenDistributorUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IPancakeRouter.sol\\\";\\n\\ncontract WrappedTokenDistributorUpgradeable is Initializable{\\n    IPancakeRouter02 internal swapRouter;\\n    address internal BUSD_CONTRACT_ADDRESS;\\n    address internal WRAPPED_Token_CONTRACT_ADDRESS;\\n\\n    event DistributedBTC(address indexed to, uint256 amount);\\n\\n    function __WrappedTokenDistributor_initialize(\\n        address swapRouterAddress,\\n        address BUSDContractAddress,\\n        address WrappedTokenContractAddress\\n    ) public initializer {\\n        swapRouter = IPancakeRouter02(swapRouterAddress);\\n        BUSD_CONTRACT_ADDRESS = BUSDContractAddress;\\n        WRAPPED_Token_CONTRACT_ADDRESS = WrappedTokenContractAddress;\\n    }\\n\\n    /**\\n     * @param _to Reciever address\\n     * @param _usdAmount USD Amount\\n     * @param _wrappedTokenAmount Wrapped Token Amount\\n     */\\n    function transferTokensThroughSwap(\\n        address _to,\\n        uint256 _usdAmount,\\n        uint256 _wrappedTokenAmount,\\n        uint256 _deadline\\n    ) internal {\\n        require(_to != address(0));\\n        // Get max USD price we can spend for this amount.\\n        swapRouter.swapExactTokensForTokens(\\n            _usdAmount,\\n            _wrappedTokenAmount,\\n            getPathForUSDToWrappedToken(),\\n            _to,\\n            _deadline\\n        );\\n    }\\n\\n    /**\\n     * @param _amount Amount\\n     */\\n    function getEstimatedWrappedTokenForUSD(uint256 _amount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256[] memory wrappedTokenAmount =\\n            swapRouter.getAmountsOut(_amount, getPathForUSDToWrappedToken());\\n        // since in the path the wrappedToken is the second one, so we should retuen the second one also here    \\n        return wrappedTokenAmount[1];\\n    }\\n\\n    function getPathForUSDToWrappedToken() public view returns (address[] memory) {\\n        address[] memory path = new address[](2);\\n        path[0] = BUSD_CONTRACT_ADDRESS;\\n        path[1] = WRAPPED_Token_CONTRACT_ADDRESS;\\n\\n        return path;\\n    }\\n\\n    function getSwapRouter() public view returns (address) {\\n        return address(swapRouter);\\n    }\\n}\\n\",\"keccak256\":\"0xd7e60cfdab6b448bf1119bd8f7a320db4ef747d1e0e1d81c5c74795de00870f6\",\"license\":\"UNLICENSED\"},\"contracts/Price/PriceConsumerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\ncontract PriceConsumerUpgradeable is Initializable {\\n    AggregatorV3Interface internal priceFeed;\\n\\n    /**\\n     * @param _oracle The chainlink node oracle address to send requests\\n    */\\n    function __PriceConsumer_initialize(address _oracle) public initializer {\\n        priceFeed = AggregatorV3Interface(_oracle);\\n    }\\n\\n    /**\\n     * @notice Returns decimals for oracle contract\\n    */\\n    function getDecimals() public view returns (uint8) {\\n        uint8 decimals = priceFeed.decimals();\\n        return decimals;\\n    }\\n\\n    /**\\n     * @notice Returns the latest price from oracle contract\\n    */\\n    function getLatestPrice() public view returns (uint256) {\\n        (, int256 price, , , ) = priceFeed.latestRoundData();\\n\\n        return price >= 0 ? uint256(price) : 0;\\n    }\\n}\\n\",\"keccak256\":\"0x0e06dab9db0ea365065a1a636d6a28d6856a5459301e23bd456a22bb6acc575d\",\"license\":\"UNLICENSED\"},\"contracts/Staking/StakingPoolStorageStructure.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport \\\"../Distribution/USDRetriever.sol\\\";\\nimport \\\"../Price/PriceConsumerUpgradeable.sol\\\";\\nimport \\\"../Distribution/WrappedTokenDistributorUpgradeable.sol\\\";\\n\\nimport \\\"../libraries/BasisPoints.sol\\\";\\nimport \\\"../libraries/CalculateRewardLib.sol\\\";\\nimport \\\"../libraries/IndexedClaimRewardLib.sol\\\";\\nimport \\\"../libraries/ClaimRewardLib.sol\\\";\\n\\nimport \\\"../interfaces/ITotemToken.sol\\\";\\nimport \\\"../interfaces/IRewardManager.sol\\\";\\n\\ncontract StakingPoolStorageStructure is \\n    OwnableUpgradeable,  \\n    PriceConsumerUpgradeable,\\n    USDRetriever,\\n    WrappedTokenDistributorUpgradeable\\n{\\n    address public stakingPoolImplementation;\\n    address public poolCreator;\\n    address public oracleContract;\\n\\n    /**\\n     * @notice Declared for passing the needed params to libraries.\\n     */\\n    struct LibParams {\\n        uint256 launchDate;\\n        uint256 lockTime;\\n        uint256 maturityTime;\\n        uint256 maturingPrice;\\n        uint256 usdPrizeAmount;\\n        uint256 prizeAmount;\\n        uint256 stakeApr;\\n        uint256 collaborativeReward;\\n        uint256 oracleDecimals;\\n        bool isEnhancedEnabled;\\n        bool isMatured;\\n    }\\n\\n    struct StakeWithPrediction {\\n        uint256 stakedBalance;\\n        uint256 stakedTime;\\n        uint256 amountWithdrawn;\\n        uint256 lastWithdrawalTime;\\n        uint256 pricePrediction;\\n        uint256 difference;\\n        uint256 rank;\\n        bool prizeRewardWithdrawn;\\n        bool didUnstake;\\n    }\\n\\n    struct Staker {\\n        address stakerAddress;\\n        uint256 index;\\n    }\\n\\n    struct PrizeRewardRate {\\n        uint256 rank;\\n        uint256 percentage;\\n    }\\n\\n    LibParams public lps;\\n\\n    PrizeRewardRate[] public prizeRewardRates;\\n    Staker[] public stakers;\\n    Staker[] public sortedStakers;\\n\\n    mapping(address => StakeWithPrediction[]) public predictions;\\n\\n    ITotemToken public totemToken;\\n    IRewardManager public rewardManager;\\n    IERC20 public wrappedToken;\\n\\n    string public wrappedTokenSymbol;\\n    string public poolType;\\n\\n    uint256 public constant sizeLimitRangeRate = 5;\\n\\n    uint256 public launchDate;\\n    uint256 public lockTime;\\n    uint256 public maturityTime;\\n    uint256 public sizeAllocation;\\n    uint256 public stakeApr;\\n    uint256 public prizeAmount;\\n    /**\\n     * @notice usdPrizeAmount is the enabler of WrappedToken rewarder; If it is set to 0 \\n            then the pool is only TOTM rewarder.\\n     */\\n    uint256 public usdPrizeAmount;\\n    uint256 public stakeTaxRate;\\n    uint256 public minimumStakeAmount;\\n    uint256 public totalStaked;\\n    uint256 public maturingPrice;\\n    uint256 public potentialCollabReward;\\n    uint256 public collaborativeRange;\\n    /**\\n     * @notice Based on the white paper, the collaborative reward can be 20% (2000),\\n             25% (2500) or 35% (3500).\\n     */\\n    uint256 public collaborativeReward;\\n    uint256 public oracleDecimals; \\n\\n    bool public isAnEmergency;\\n    bool public isEnhancedEnabled;\\n    bool public isActive;\\n    bool public isLocked;\\n    bool public isMatured;\\n    bool public isDeleted;\\n    /**\\n     * @dev StakingPoolImplementation can't be upgraded unless superAdmin sets this flag.\\n     */\\n    bool public upgradeEnabled;\\n}\\n\",\"keccak256\":\"0x2fe6ebfad893056089253a01b1909f029d87702709f4b4b1b319d99d06ebd1ce\",\"license\":\"UNLICENSED\"},\"contracts/interfaces/IPancakeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\",\"keccak256\":\"0x40ff7201ca90e848ee6f006c4d114891619f28c21e713d74dc62b1ffc48d0461\",\"license\":\"UNLICENSED\"},\"contracts/interfaces/IRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IRewardManager {\\n\\n    function setOperator(address _newOperator) external;\\n\\n    function addPool(address _poolAddress) external;\\n\\n    function rewardUser(address _user, uint256 _amount) external;\\n\\n    event SetOperator(address operator);\\n    event SetRewarder(address rewarder);\\n\\n}\",\"keccak256\":\"0xab39a767c897abdfa93b0a33593cd3c179fd5222f2a37de798d298ccf66e5adb\",\"license\":\"UNLICENSED\"},\"contracts/interfaces/ITotemToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface ITotemToken {\\n    \\n    function setLocker(address _locker) external;\\n\\n    function setDistributionTeamsAddresses(\\n        address _CommunityDevelopmentAddr,\\n        address _StakingRewardsAddr,\\n        address _LiquidityPoolAddr,\\n        address _PublicSaleAddr,\\n        address _AdvisorsAddr,\\n        address _SeedInvestmentAddr,\\n        address _PrivateSaleAddr,\\n        address _TeamAllocationAddr,\\n        address _StrategicRoundAddr\\n    ) external;\\n\\n    function distributeTokens() external;\\n\\n    function setTaxRate(uint256 newTaxRate) external;\\n\\n    function setTaxExemptStatus(address account, bool status) external;\\n\\n    function setTaxationWallet(address newTaxationWallet) external;\\n\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function taxRate() external returns (uint256);\\n\\n    function taxationWallet() external returns (address);\\n\\n    function taxExempt(address _msgSender) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x1ba963229ac039a0550990884eb976a06fb2fe7691848ff27af1c14574346531\",\"license\":\"UNLICENSED\"},\"contracts/libraries/BasisPoints.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary BasisPoints {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant BASIS_POINTS = 10000;\\n\\n    function mulBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\\n        return amt.mul(bp).div(BASIS_POINTS);\\n    }\\n\\n    function divBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\\n        require(bp > 0, \\\"Cannot divide by zero.\\\");\\n        return amt.mul(BASIS_POINTS).div(bp);\\n    }\\n\\n    function addBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\\n        if (amt == 0) return 0;\\n        if (bp == 0) return amt;\\n        return amt.add(mulBP(amt, bp));\\n    }\\n\\n    function subBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\\n        if (amt == 0) return 0;\\n        if (bp == 0) return amt;\\n        return amt.sub(mulBP(amt, bp));\\n    }\\n}\\n\",\"keccak256\":\"0xcbe25ead953d92501d8fc100fbc9d1c5d3885b6360b3619309063fdd3b874a31\",\"license\":\"UNLICENSED\"},\"contracts/libraries/CalculateRewardLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/BasisPoints.sol\\\";\\nimport \\\"../Staking/StakingPoolStorageStructure.sol\\\";\\n\\nlibrary CalculateRewardLib {\\n\\n    using BasisPoints for uint256;\\n    using SafeMath for uint256;\\n\\n    uint256 public constant foo = 0;\\n\\n    function getTotalStakedBalance(StakingPoolStorageStructure.StakeWithPrediction[] storage _staker)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_staker.length == 0) return 0;\\n\\n        uint256 totalStakedBalance = 0;\\n        for (uint256 i = 0; i < _staker.length; i++) {\\n            if (!_staker[i].didUnstake) {\\n                totalStakedBalance = totalStakedBalance.add(\\n                    _staker[i].stakedBalance\\n                );\\n            }\\n        }\\n\\n        return totalStakedBalance;\\n    }\\n\\n    /**\\n     * @notice the reward formula is:\\n          ((1 + stakeAPR +enhancedReward)^((MaturingDate - StakingDate)/365) - 1) * StakingBalance\\n    */\\n    function _getStakingRewardPerStake(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \\n        uint256 _stakeIndex,\\n        StakingPoolStorageStructure.LibParams storage _lps\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 maturityDate = \\n            _lps.launchDate + \\n            _lps.lockTime + \\n            _lps.maturityTime;\\n\\n        uint256 timeTo =\\n            block.timestamp > maturityDate ? maturityDate : block.timestamp;\\n\\n        uint256 enhancedApr;\\n        if ( _lps.isEnhancedEnabled ) {\\n            enhancedApr = _getEnhancedRewardRate(\\n                _staker[_stakeIndex].stakedTime,\\n                _lps\\n            );\\n        }\\n\\n        uint256 rewardPerStake = _calcStakingReturn(\\n            _lps.stakeApr.add(enhancedApr),\\n            timeTo.sub(_staker[_stakeIndex].stakedTime),\\n            _staker[_stakeIndex].stakedBalance\\n        );\\n\\n        rewardPerStake = rewardPerStake.sub(_staker[_stakeIndex].amountWithdrawn);\\n\\n        return rewardPerStake;\\n    }\\n\\n    function _getEnhancedRewardRate(\\n        uint256 stakedTime,\\n        StakingPoolStorageStructure.LibParams storage _lps\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n\\n        if (!_lps.isEnhancedEnabled) {\\n            return 0;\\n        }\\n\\n        uint256 lockDate = _lps.launchDate.add(_lps.lockTime);\\n        uint256 difference = lockDate.sub(stakedTime);\\n\\n        if (difference < 48 hours) {\\n            return 0;\\n        } else if (difference < 72 hours) {\\n            return 100;\\n        } else if (difference < 96 hours) {\\n            return 200;\\n        } else if (difference < 120 hours) {\\n            return 300;\\n        } else if (difference < 144 hours) {\\n            return 400;\\n        } else {\\n            return 500;\\n        }\\n    }\\n\\n    function _calcStakingReturn(uint256 totalRewardRate, uint256 timeDuration, uint256 totalStakedBalance) \\n        internal \\n        pure\\n        returns (uint256) \\n    {\\n        uint256 yearInSeconds = 365 days;\\n\\n        uint256 first = (yearInSeconds**2)\\n            .mul(10**8);\\n\\n        uint256 second = timeDuration\\n            .mul(totalRewardRate) \\n            .mul(yearInSeconds)\\n            .mul(5000);\\n        \\n        uint256 third = totalRewardRate\\n            .mul(yearInSeconds**2)\\n            .mul(5000);\\n\\n        uint256 forth = (timeDuration**2)\\n            .mul(totalRewardRate**2)\\n            .div(6);\\n\\n        uint256 fifth = timeDuration\\n            .mul(totalRewardRate**2)\\n            .mul(yearInSeconds)\\n            .div(2);\\n\\n        uint256 sixth = (totalRewardRate**2)\\n            .mul(yearInSeconds**2)\\n            .div(3);\\n \\n        uint256 rewardPerStake = first.add(second).add(forth).add(sixth);\\n\\n        rewardPerStake = rewardPerStake.sub(third).sub(fifth);\\n\\n        rewardPerStake = rewardPerStake\\n            .mul(totalRewardRate)\\n            .mul(timeDuration);\\n\\n        rewardPerStake = rewardPerStake\\n            .mul(totalStakedBalance)\\n            .div(yearInSeconds**3)\\n            .div(10**12);\\n\\n        return rewardPerStake; \\n    }\\n\\n    function _getPercentageReward(\\n        uint256 _rank, \\n        StakingPoolStorageStructure.PrizeRewardRate[] storage _prizeRewardRates\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        for (uint256 i = 0; i < _prizeRewardRates.length; i++) {\\n            if (_rank <= _prizeRewardRates[i].rank) {\\n                return _prizeRewardRates[i].percentage;\\n            }\\n        }\\n\\n        return 0;\\n    }        \\n\\n\\n\\n}\",\"keccak256\":\"0xc712e3d29c87edcd36233abc68310220ad0914694200663dded7328044638e8b\",\"license\":\"UNLICENSED\"},\"contracts/libraries/ClaimRewardLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CalculateRewardLib.sol\\\";\\nimport \\\"../libraries/BasisPoints.sol\\\";\\nimport \\\"../Staking/StakingPoolStorageStructure.sol\\\";\\n\\nlibrary ClaimRewardLib {\\n\\n    using CalculateRewardLib for *;\\n    using BasisPoints for uint256; \\n    using SafeMath for uint256;\\n\\n    uint256 public constant foo = 0;\\n\\n    function withdrawStakingReturn(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker,\\n        StakingPoolStorageStructure.LibParams storage _lps\\n    )\\n        public \\n    {\\n        \\n        if (_staker.length == 0) return;\\n\\n        for (uint256 i = 0; i < _staker.length; i++) {\\n            uint256 rewardPerStake = CalculateRewardLib._getStakingRewardPerStake(\\n                _staker, \\n                i, \\n                _lps);\\n\\n            _staker[i].lastWithdrawalTime = block.timestamp;\\n            _staker[i].amountWithdrawn = _staker[i].amountWithdrawn.add(\\n                rewardPerStake\\n            );\\n        }\\n    }\\n\\n    function withdrawPrize(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker\\n    ) \\n        public\\n    {\\n        if (_staker.length == 0) return;\\n\\n        for (uint256 i = 0; i < _staker.length; i++) {\\n            _staker[i].prizeRewardWithdrawn = true;\\n        }\\n    }\\n\\n    function withdrawStakedBalance(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker\\n    )\\n        public \\n    {\\n        \\n        if (_staker.length == 0) return;\\n\\n        for (uint256 i = 0; i < _staker.length; i++) {\\n            _staker[i].didUnstake = true;\\n        }\\n    }\\n\\n    function getStakingReturn(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker,\\n        StakingPoolStorageStructure.LibParams storage _lps  \\n    ) \\n        public \\n        view \\n        returns (uint256) \\n    {\\n        if (_staker.length == 0) return 0;\\n\\n        uint256 reward = 0;\\n        for (uint256 i = 0; i < _staker.length; i++) {\\n            uint256 rewardPerStake = CalculateRewardLib._getStakingRewardPerStake(\\n                _staker,\\n                i, \\n                _lps\\n            );\\n\\n            reward = reward.add(rewardPerStake);\\n        }\\n\\n        return reward;\\n    }\\n\\n    function getPrize(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \\n        StakingPoolStorageStructure.LibParams storage _lps,\\n        StakingPoolStorageStructure.PrizeRewardRate[] storage _prizeRewardRates\\n    )\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        if (!_lps.isMatured) return (0, 0);\\n\\n        if (_staker.length == 0) return (0, 0);\\n\\n        uint256 maturingWrappedTokenPrizeAmount =\\n            (_lps.usdPrizeAmount.mul(10**_lps.oracleDecimals)).div(_lps.maturingPrice);\\n\\n        uint256 reward = 0;\\n        uint256 wrappedTokenReward = 0;\\n\\n        for (uint256 i = 0; i < _staker.length; i++) {\\n            if (!_staker[i].prizeRewardWithdrawn) {\\n\\n                uint256 _percent = CalculateRewardLib._getPercentageReward(\\n                    _staker[i].rank,\\n                    _prizeRewardRates\\n                );\\n\\n                reward = reward.add(\\n                            _lps.prizeAmount.mulBP(_percent)\\n                        );\\n\\n                wrappedTokenReward = wrappedTokenReward.add(\\n                            maturingWrappedTokenPrizeAmount\\n                                .mulBP(_percent)\\n                        );        \\n            }\\n        }\\n\\n        if (_lps.collaborativeReward > 0) {\\n            reward = reward.addBP(_lps.collaborativeReward);\\n            wrappedTokenReward = wrappedTokenReward.addBP(_lps.collaborativeReward);\\n        }\\n\\n        return (reward, wrappedTokenReward);\\n    }\\n\\n}\\n\\n\",\"keccak256\":\"0xec7d4e480f58753b28aa26b3a2e588c256303039bbeeac3e241ee803af5121a4\",\"license\":\"UNLICENSED\"},\"contracts/libraries/IndexedClaimRewardLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CalculateRewardLib.sol\\\";\\nimport \\\"../libraries/BasisPoints.sol\\\";\\nimport \\\"../Staking/StakingPoolStorageStructure.sol\\\";\\n\\nlibrary IndexedClaimRewardLib {\\n\\n    using CalculateRewardLib for *;\\n    using BasisPoints for uint256; \\n    using SafeMath for uint256;\\n\\n    uint256 public constant foo = 0;\\n\\n    function withdrawIndexedStakingReturn(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \\n        uint256 _stakeIndex,\\n        StakingPoolStorageStructure.LibParams storage _lps\\n    ) \\n        public\\n    {\\n        if (_staker.length == 0) return;\\n        if (_stakeIndex >= _staker.length) return;\\n\\n        uint256 rewardPerStake = CalculateRewardLib._getStakingRewardPerStake(\\n            _staker, \\n            _stakeIndex,\\n            _lps\\n        );\\n\\n        _staker[_stakeIndex].lastWithdrawalTime = block.timestamp;\\n        _staker[_stakeIndex].amountWithdrawn = _staker[_stakeIndex].amountWithdrawn.add(\\n            rewardPerStake\\n        );\\n    }\\n\\n    function withdrawIndexedPrize(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \\n        uint256 _stakeIndex\\n    ) \\n        public \\n    {\\n        if (_staker.length == 0) return;\\n        if (_staker[_stakeIndex].prizeRewardWithdrawn) return;\\n\\n        _staker[_stakeIndex].prizeRewardWithdrawn = true;\\n    }\\n\\n    function withdrawIndexedStakedBalance(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \\n        uint256 _stakeIndex\\n    ) \\n        public\\n    {\\n        if (_staker.length == 0) return;\\n        if (_stakeIndex >= _staker.length) return;\\n\\n        _staker[_stakeIndex].didUnstake = true;\\n    }\\n\\n    function getIndexedStakedBalance(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \\n        uint256 _stakeIndex\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_staker.length == 0) return 0;\\n        if (_stakeIndex >= _staker.length) return 0; \\n\\n        uint256 totalStakedBalance = 0;\\n\\n        if (!_staker[_stakeIndex].didUnstake) {\\n            totalStakedBalance = totalStakedBalance.add(\\n                _staker[_stakeIndex].stakedBalance\\n            );\\n        }\\n\\n        return totalStakedBalance;\\n    }\\n\\n    function getIndexedStakingReturn(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \\n        uint256 _stakeIndex,\\n        StakingPoolStorageStructure.LibParams storage _lps\\n    ) \\n        public\\n        view \\n        returns (uint256) \\n    {\\n        if (_staker.length == 0) return 0;\\n        if (_stakeIndex >= _staker.length) return 0;\\n\\n        uint256 reward = 0;\\n        \\n        uint256 rewardPerStake = CalculateRewardLib._getStakingRewardPerStake(\\n            _staker, \\n            _stakeIndex,\\n            _lps\\n        );\\n        reward = reward.add(rewardPerStake);\\n\\n        return reward;\\n    }\\n\\n    function getIndexedPrize(\\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \\n        uint256 _stakeIndex,\\n        StakingPoolStorageStructure.LibParams storage _lps,\\n        StakingPoolStorageStructure.PrizeRewardRate[] storage _prizeRewardRates\\n    )\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        if (!_lps.isMatured) return (0, 0);\\n\\n        if (_staker.length == 0) return (0, 0);\\n\\n        if (_stakeIndex >= _staker.length) return (0,0);\\n\\n        if (_staker[_stakeIndex].prizeRewardWithdrawn) return (0, 0);\\n\\n        uint256 maturingWrappedTokenPrizeAmount =\\n            (_lps.usdPrizeAmount.mul(10**_lps.oracleDecimals)).div(_lps.maturingPrice);\\n\\n        uint256 reward = 0;\\n        uint256 wrappedTokenReward = 0;\\n\\n        uint256 _percent = CalculateRewardLib._getPercentageReward(\\n            _staker[_stakeIndex].rank,\\n            _prizeRewardRates\\n        );\\n\\n        reward = reward.add(\\n                        _lps.prizeAmount.mulBP(_percent)\\n                    );\\n\\n        wrappedTokenReward = wrappedTokenReward.add(\\n                        maturingWrappedTokenPrizeAmount\\n                            .mulBP(_percent)\\n                    );            \\n\\n        if (_lps.collaborativeReward > 0) {\\n            reward = reward.addBP(_lps.collaborativeReward);\\n            wrappedTokenReward = wrappedTokenReward.addBP(_lps.collaborativeReward);\\n        }\\n\\n        return (reward, wrappedTokenReward);\\n    }\\n}\\n\\n\",\"keccak256\":\"0xbc6ba78bfd18f5ed2e8b635f25eb3934e224a6ccea017141f9354ba2112e6db8\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x610c8d61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c8063c298557811610065578063c2985578146100ea578063eaff3050146100f2578063ec8ecc0214610112578063f7ac9cba1461013257610087565b80634f1604231461008c5780635eac7af3146100b557806393aaeaf9146100c8575b600080fd5b61009f61009a366004610a27565b610153565b6040516100ac9190610a83565b60405180910390f35b61009f6100c3366004610a06565b61019a565b8180156100d457600080fd5b506100e86100e3366004610a06565b610247565b005b61009f6102dc565b8180156100fe57600080fd5b506100e861010d366004610a27565b6102e1565b81801561011e57600080fd5b506100e861012d366004610a06565b6103be565b610145610140366004610a52565b610424565b6040516100ac929190610a8c565b825460009061016457506000610193565b8354831061017457506000610193565b6000806101828686866105a4565b905061018e8282610717565b925050505b9392505050565b81546000906101ab57506000610241565b825482106101bb57506000610241565b60008383815481106101dd57634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160070160019054906101000a900460ff1661023e5761023b84848154811061022357634e487b7160e01b600052603260045260246000fd5b60009182526020909120600890910201548290610717565b90505b90505b92915050565b8154610252576102d8565b81818154811061027257634e487b7160e01b600052603260045260246000fd5b600091825260209091206007600890920201015460ff1615610293576102d8565b60018282815481106102b557634e487b7160e01b600052603260045260246000fd5b60009182526020909120600890910201600701805460ff19169115159190911790555b5050565b600081565b82546102ec576103b9565b825482106102f9576103b9565b60006103068484846105a4565b90504284848154811061032957634e487b7160e01b600052603260045260246000fd5b9060005260206000209060080201600301819055506103828185858154811061036257634e487b7160e01b600052603260045260246000fd5b90600052602060002090600802016002015461071790919063ffffffff16565b8484815481106103a257634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160020181905550505b505050565b81546103c9576102d8565b815481106103d6576102d8565b60018282815481106103f857634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160070160016101000a81548160ff0219169083151502179055505050565b60098201546000908190610100900460ff166104455750600090508061059b565b85546104565750600090508061059b565b855485106104695750600090508061059b565b85858154811061048957634e487b7160e01b600052603260045260246000fd5b600091825260209091206007600890920201015460ff16156104b05750600090508061059b565b60006104df85600301546104d98760080154600a6104ce9190610b0f565b600489015490610723565b9061072f565b905060008060006105218a8a8154811061050957634e487b7160e01b600052603260045260246000fd5b9060005260206000209060080201600601548861073b565b905061054461053d828a600501546107d690919063ffffffff16565b8490610717565b925061055a61055385836107d6565b8390610717565b6007890154909250156105935760078801546105779084906107e8565b92506105908860070154836107e890919063ffffffff16565b91505b509093509150505b94509492505050565b6000808260020154836001015484600001546105c09190610a9a565b6105ca9190610a9a565b905060008142116105db57426105dd565b815b600985015490915060009060ff161561062e5761062b87878154811061061357634e487b7160e01b600052603260045260246000fd5b90600052602060002090600802016001015486610810565b90505b60006106c561064a83886006015461071790919063ffffffff16565b61068e8a8a8154811061066d57634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160010154866108c790919063ffffffff16565b8a8a815481106106ae57634e487b7160e01b600052603260045260246000fd5b9060005260206000209060080201600001546108d3565b905061070b8888815481106106ea57634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160020154826108c790919063ffffffff16565b98975050505050505050565b600061023e8284610a9a565b600061023e8284610bf0565b600061023e8284610ab2565b6000805b82548110156107cc5782818154811061076857634e487b7160e01b600052603260045260246000fd5b90600052602060002090600202016000015484116107ba578281815481106107a057634e487b7160e01b600052603260045260246000fd5b906000526020600020906002020160010154915050610241565b806107c481610c26565b91505061073f565b5060009392505050565b600061023e6127106104d98585610723565b6000826107f757506000610241565b81610803575081610241565b61023e61053d84846107d6565b600981015460009060ff1661082757506000610241565b6001820154825460009161083b9190610717565b9050600061084982866108c7565b90506202a30081101561086157600092505050610241565b6203f48081101561087757606492505050610241565b6205460081101561088d5760c892505050610241565b620697808110156108a45761012c92505050610241565b6207e9008110156108bb5761019092505050610241565b6101f492505050610241565b600061023e8284610c0f565b60006301e13380816108f46305f5e1006108ee600285610b1e565b90610723565b9050600061090a6113886108ee85818a8c610723565b905060006109296113886108ee610922600288610b1e565b8b90610723565b9050600061094b60066104d961094060028d610b1e565b6108ee60028d610b1e565b9050600061096f60026104d9886108ee60028f6109689190610b1e565b8e90610723565b9050600061099360036104d961098660028b610b1e565b60028f6108ee9190610b1e565b905060006109ad826109a786818b8b610717565b90610717565b90506109c3836109bd83886108c7565b906108c7565b90506109d38b6108ee838f610723565b90506109f664e8d4a510006104d96109ec60038c610b1e565b6104d9858f610723565b9c9b505050505050505050505050565b60008060408385031215610a18578182fd5b50508035926020909101359150565b600080600060608486031215610a3b578081fd5b505081359360208301359350604090920135919050565b60008060008060808587031215610a67578081fd5b5050823594602084013594506040840135936060013592509050565b90815260200190565b918252602082015260400190565b60008219821115610aad57610aad610c41565b500190565b600082610acd57634e487b7160e01b81526012600452602481fd5b500490565b80825b6001808611610ae4575061059b565b818704821115610af657610af6610c41565b80861615610b0357918102915b9490941c938002610ad5565b600061023e6000198484610b2c565b600061023e60001960ff8516845b600082610b3b57506001610193565b81610b4857506000610193565b8160018114610b5e5760028114610b6857610b95565b6001915050610193565b60ff841115610b7957610b79610c41565b6001841b915084821115610b8f57610b8f610c41565b50610193565b5060208310610133831016604e8410600b8410161715610bc8575081810a83811115610bc357610bc3610c41565b610193565b610bd58484846001610ad2565b808604821115610be757610be7610c41565b02949350505050565b6000816000190483118215151615610c0a57610c0a610c41565b500290565b600082821015610c2157610c21610c41565b500390565b6000600019821415610c3a57610c3a610c41565b5060010190565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220ce7ceef1218da8a5cd151b51efbd13c317028091b9172dfafbaddea08fd49e3564736f6c63430008000033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c8063c298557811610065578063c2985578146100ea578063eaff3050146100f2578063ec8ecc0214610112578063f7ac9cba1461013257610087565b80634f1604231461008c5780635eac7af3146100b557806393aaeaf9146100c8575b600080fd5b61009f61009a366004610a27565b610153565b6040516100ac9190610a83565b60405180910390f35b61009f6100c3366004610a06565b61019a565b8180156100d457600080fd5b506100e86100e3366004610a06565b610247565b005b61009f6102dc565b8180156100fe57600080fd5b506100e861010d366004610a27565b6102e1565b81801561011e57600080fd5b506100e861012d366004610a06565b6103be565b610145610140366004610a52565b610424565b6040516100ac929190610a8c565b825460009061016457506000610193565b8354831061017457506000610193565b6000806101828686866105a4565b905061018e8282610717565b925050505b9392505050565b81546000906101ab57506000610241565b825482106101bb57506000610241565b60008383815481106101dd57634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160070160019054906101000a900460ff1661023e5761023b84848154811061022357634e487b7160e01b600052603260045260246000fd5b60009182526020909120600890910201548290610717565b90505b90505b92915050565b8154610252576102d8565b81818154811061027257634e487b7160e01b600052603260045260246000fd5b600091825260209091206007600890920201015460ff1615610293576102d8565b60018282815481106102b557634e487b7160e01b600052603260045260246000fd5b60009182526020909120600890910201600701805460ff19169115159190911790555b5050565b600081565b82546102ec576103b9565b825482106102f9576103b9565b60006103068484846105a4565b90504284848154811061032957634e487b7160e01b600052603260045260246000fd5b9060005260206000209060080201600301819055506103828185858154811061036257634e487b7160e01b600052603260045260246000fd5b90600052602060002090600802016002015461071790919063ffffffff16565b8484815481106103a257634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160020181905550505b505050565b81546103c9576102d8565b815481106103d6576102d8565b60018282815481106103f857634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160070160016101000a81548160ff0219169083151502179055505050565b60098201546000908190610100900460ff166104455750600090508061059b565b85546104565750600090508061059b565b855485106104695750600090508061059b565b85858154811061048957634e487b7160e01b600052603260045260246000fd5b600091825260209091206007600890920201015460ff16156104b05750600090508061059b565b60006104df85600301546104d98760080154600a6104ce9190610b0f565b600489015490610723565b9061072f565b905060008060006105218a8a8154811061050957634e487b7160e01b600052603260045260246000fd5b9060005260206000209060080201600601548861073b565b905061054461053d828a600501546107d690919063ffffffff16565b8490610717565b925061055a61055385836107d6565b8390610717565b6007890154909250156105935760078801546105779084906107e8565b92506105908860070154836107e890919063ffffffff16565b91505b509093509150505b94509492505050565b6000808260020154836001015484600001546105c09190610a9a565b6105ca9190610a9a565b905060008142116105db57426105dd565b815b600985015490915060009060ff161561062e5761062b87878154811061061357634e487b7160e01b600052603260045260246000fd5b90600052602060002090600802016001015486610810565b90505b60006106c561064a83886006015461071790919063ffffffff16565b61068e8a8a8154811061066d57634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160010154866108c790919063ffffffff16565b8a8a815481106106ae57634e487b7160e01b600052603260045260246000fd5b9060005260206000209060080201600001546108d3565b905061070b8888815481106106ea57634e487b7160e01b600052603260045260246000fd5b906000526020600020906008020160020154826108c790919063ffffffff16565b98975050505050505050565b600061023e8284610a9a565b600061023e8284610bf0565b600061023e8284610ab2565b6000805b82548110156107cc5782818154811061076857634e487b7160e01b600052603260045260246000fd5b90600052602060002090600202016000015484116107ba578281815481106107a057634e487b7160e01b600052603260045260246000fd5b906000526020600020906002020160010154915050610241565b806107c481610c26565b91505061073f565b5060009392505050565b600061023e6127106104d98585610723565b6000826107f757506000610241565b81610803575081610241565b61023e61053d84846107d6565b600981015460009060ff1661082757506000610241565b6001820154825460009161083b9190610717565b9050600061084982866108c7565b90506202a30081101561086157600092505050610241565b6203f48081101561087757606492505050610241565b6205460081101561088d5760c892505050610241565b620697808110156108a45761012c92505050610241565b6207e9008110156108bb5761019092505050610241565b6101f492505050610241565b600061023e8284610c0f565b60006301e13380816108f46305f5e1006108ee600285610b1e565b90610723565b9050600061090a6113886108ee85818a8c610723565b905060006109296113886108ee610922600288610b1e565b8b90610723565b9050600061094b60066104d961094060028d610b1e565b6108ee60028d610b1e565b9050600061096f60026104d9886108ee60028f6109689190610b1e565b8e90610723565b9050600061099360036104d961098660028b610b1e565b60028f6108ee9190610b1e565b905060006109ad826109a786818b8b610717565b90610717565b90506109c3836109bd83886108c7565b906108c7565b90506109d38b6108ee838f610723565b90506109f664e8d4a510006104d96109ec60038c610b1e565b6104d9858f610723565b9c9b505050505050505050505050565b60008060408385031215610a18578182fd5b50508035926020909101359150565b600080600060608486031215610a3b578081fd5b505081359360208301359350604090920135919050565b60008060008060808587031215610a67578081fd5b5050823594602084013594506040840135936060013592509050565b90815260200190565b918252602082015260400190565b60008219821115610aad57610aad610c41565b500190565b600082610acd57634e487b7160e01b81526012600452602481fd5b500490565b80825b6001808611610ae4575061059b565b818704821115610af657610af6610c41565b80861615610b0357918102915b9490941c938002610ad5565b600061023e6000198484610b2c565b600061023e60001960ff8516845b600082610b3b57506001610193565b81610b4857506000610193565b8160018114610b5e5760028114610b6857610b95565b6001915050610193565b60ff841115610b7957610b79610c41565b6001841b915084821115610b8f57610b8f610c41565b50610193565b5060208310610133831016604e8410600b8410161715610bc8575081810a83811115610bc357610bc3610c41565b610193565b610bd58484846001610ad2565b808604821115610be757610be7610c41565b02949350505050565b6000816000190483118215151615610c0a57610c0a610c41565b500290565b600082821015610c2157610c21610c41565b500390565b6000600019821415610c3a57610c3a610c41565b5060010190565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220ce7ceef1218da8a5cd151b51efbd13c317028091b9172dfafbaddea08fd49e3564736f6c63430008000033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}